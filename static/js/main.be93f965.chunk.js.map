{"version":3,"sources":["PathFinding/Algorithms.js","PathFinding/Node.js","PathFinding/SearchGrid.js","PathFinding/Pathfinder.js","App.js","index.js","PathFinding/SearchGrid.module.css"],"names":["Algorithms","item","color","grid","stackOfNodes","visited","nodesTouched","destNode","endNode","currNode","currentNode","push","x","y","neighbors","i","length","check","console","log","numberOfRows","numberOfColumns","indexOf","nodeToPush","graph","parent","forEach","this","changeColorToOrange","changeColorToBlue","pop","shift","Component","Node","SearchGrid","props","state","startNode","newGraph","currRow","j","temp","update","bind","setState","Pathfinder","algorithm","searching","intervalID","undefined","searchAlgos","changeToDijkstra","changeToBfs","changeToDfs","changeToAstar","startSearch","stopSearch","search","startInterval","stopInterval","reset","copyGrid","newGrid","newStackOfNodes","newVisited","newNodesTouched","continueSearch","dfsStep","bfsStep","window","setInterval","clearInterval","stopSearchButton","startSearchButton","onClick","disabled","gridRender","map","style","backgroundColor","className","styles","App","ReactDOM","render","StrictMode","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.be93f965.chunk.js","sourcesContent":["import {Component} from 'react';\n\n// Algorithms takes an algorithm name from PathFinder and the Grid from SearchGrid to execute the specified the algorithm\nclass Algorithms extends Component{\n    \n    changeColorToOrange(item){\n        item.color = 'orange';\n    }\n\n    changeColorToBlue(item){\n        item.color = 'blue';\n    }\n    \n    dfsStep(grid, stackOfNodes, visited, nodesTouched){\n        let destNode = grid.endNode;\n        let currNode = grid.currentNode;\n\n        visited.push(currNode);\n\n        if ( currNode.x === destNode.x && currNode.y === destNode.y ){\n            grid.endNode.color = 'pink';\n            return [grid, stackOfNodes, visited, nodesTouched];\n        }\n\n        let neighbors = [];\n        // Add the 4 neighbors.\n        neighbors.push([currNode.x+1, currNode.y]);\n        neighbors.push([currNode.x-1, currNode.y]);\n        neighbors.push([currNode.x, currNode.y+1]);\n        neighbors.push([currNode.x, currNode.y-1]);\n        for ( let i = 0; i < neighbors.length; i++ ){\n            let check = neighbors[i];\n            console.log(check);\n            if ( check[0] >= 0 && check[0] < grid.numberOfRows && check[1] >= 0 && check[1] < grid.numberOfColumns ){\n                if ( nodesTouched.indexOf(check[0]*grid.numberOfColumns + check[1]) === -1 ){\n                    let nodeToPush = grid.graph[check[0]][check[1]];\n                    console.log(\"This node added is \", nodeToPush);\n                    nodeToPush.parent = currNode;\n                    stackOfNodes.push(nodeToPush);\n                    nodesTouched.push(check[0]*grid.numberOfColumns + check[1]);\n                }\n            }\n        }\n        \n        stackOfNodes.forEach(this.changeColorToOrange);\n        visited.forEach(this.changeColorToBlue);\n        if ( stackOfNodes.length >= 1 ){\n            grid.currentNode = stackOfNodes.pop();\n            grid.currentNode.color = 'green';\n        }\n\n        return [grid, stackOfNodes, visited, nodesTouched];\n    }\n\n    bfsStep(grid, stackOfNodes, visited, nodesTouched){\n        let destNode = grid.endNode;\n        let currNode = grid.currentNode;\n\n        visited.push(currNode);\n\n        if ( currNode.x === destNode.x && currNode.y === destNode.y ){\n            grid.endNode.color = 'pink';\n            return [grid, stackOfNodes, visited, nodesTouched];\n        }\n\n        let neighbors = [];\n        // Add the 4 neighbors.\n        neighbors.push([currNode.x+1, currNode.y]);\n        neighbors.push([currNode.x-1, currNode.y]);\n        neighbors.push([currNode.x, currNode.y+1]);\n        neighbors.push([currNode.x, currNode.y-1]);\n        for ( let i = 0; i < neighbors.length; i++ ){\n            let check = neighbors[i];\n            console.log(check);\n            if ( check[0] >= 0 && check[0] < grid.numberOfRows && check[1] >= 0 && check[1] < grid.numberOfColumns ){\n                if ( nodesTouched.indexOf(check[0]*grid.numberOfColumns + check[1]) === -1 ){\n                    let nodeToPush = grid.graph[check[0]][check[1]];\n                    console.log(\"This node added is \", nodeToPush);\n                    nodeToPush.parent = currNode;\n                    stackOfNodes.push(nodeToPush);\n                    nodesTouched.push(check[0]*grid.numberOfColumns + check[1]);\n                }\n            }\n        }\n        \n        stackOfNodes.forEach(this.changeColorToOrange);\n        visited.forEach(this.changeColorToBlue);\n        if ( stackOfNodes.length >= 1 ){\n            grid.currentNode = stackOfNodes.shift();\n            grid.currentNode.color = 'green';\n        }\n\n        return [grid, stackOfNodes, visited, nodesTouched];\n    }\n\n}\n\nexport default Algorithms;","// Each node is a point in the graph\nclass Node {\n    constructor(x,y,color=\"white\"){\n        this.x = x;\n        this.y = y;\n        this.color = color;\n        this.parent = null;\n    }\n\n    getX(){\n        return this.x;\n    }\n\n    getY(){\n        return this.y;\n    }\n\n    getColor(){\n        return this.color;\n    }\n\n    getParent(){\n        return this.parent;\n    }\n\n    setColor(color){\n        this.color = color;\n    }\n\n    setParent(parent){\n        this.parent = parent;\n    }\n}\n\nexport default Node","import {Component} from 'react';\nimport Node from \"./Node.js\"\n\n\n// This class contains the graph array which is manipulated by\n// the algorithms based on which algorithm we are using\n// resetBoard() - Resets the board to the initial conditions.\n// displayBoard() - Displays the board using SearchGrid.css\nclass SearchGrid extends Component {\n\n    constructor(props){\n        super(props);\n\n        this.state = {\n            numberOfRows: 25,\n            numberOfColumns: 50,\n            graph: [[]],\n            startNode: new Node(0,0, 'yellow'),\n            currentNode: new Node(0,0, 'green'),\n            endNode: new Node(0,0,'red'),\n        }\n\n        let newGraph = [];\n        for(let i = 0; i < this.state.numberOfRows; i++ ){\n            let currRow = []\n            for (let j = 0; j < this.state.numberOfColumns; j++ ){\n                let temp = new Node(i,j);\n                currRow.push(temp);\n            }\n            newGraph.push(currRow);\n        }\n\n        newGraph[0][0].color = 'yellow';\n        newGraph[this.state.numberOfRows-1][this.state.numberOfColumns-1].color = 'red';\n\n        this.state.graph = newGraph;\n        this.state.startNode = newGraph[0][0];\n        this.state.endNode = newGraph[this.state.numberOfRows-1][this.state.numberOfColumns-1];\n        this.update = this.update.bind(this);\n    }\n\n    // Resets the board to the initial state.\n    update(grid){\n        console.log(\"UPDATING THE GRID\");\n        this.setState(grid);\n    }\n}\n\nexport default SearchGrid;","import React, {Component} from 'react';\nimport Algorithms from './Algorithms.js';\nimport SearchGrid from './SearchGrid.js';\nimport styles from \"./SearchGrid.module.css\"\n\n\n// Pathfinder tells which algorithm we are using.\nclass Pathfinder extends Component {\n\n    constructor(props){\n        super(props);\n\n        this.state = {\n            algorithm: \"DFS\",\n            searching: false,\n            stackOfNodes: [],\n            visited: [],\n            nodesTouched: [],\n        };\n\n        this.grid = new SearchGrid();\n        this.intervalID = undefined;\n        this.searchAlgos = new Algorithms();\n\n        this.changeToDijkstra = this.changeToDijkstra.bind(this);\n        this.changeToBfs = this.changeToBfs.bind(this);\n        this.changeToDfs = this.changeToDfs.bind(this);\n        this.changeToAstar = this.changeToAstar.bind(this);\n        this.startSearch = this.startSearch.bind(this);\n        this.stopSearch = this.stopSearch.bind(this);\n        this.search = this.search.bind(this);\n        this.startInterval = this.startInterval.bind(this);\n        this.stopInterval = this.stopInterval.bind(this);\n        this.reset = this.reset.bind(this);\n    }\n\n    reset(){\n        this.setState({\n            searching: false,\n            stackOfNodes: [],\n            visited: [],\n            nodesTouched: [],\n        });\n        \n        let copyGrid = this.grid.state;\n        for(let i = 0; i < copyGrid.numberOfRows; i++ ){\n            for ( let j = 0; j < copyGrid.numberOfColumns; j++ ){\n                this.grid.state.graph[i][j].color = 'white';\n            }\n        }\n\n        copyGrid.graph[0][0].color = 'yellow';\n        copyGrid.graph[copyGrid.numberOfRows-1][copyGrid.numberOfColumns-1].color = \"red\";\n        copyGrid.currentNode = copyGrid.graph[0][0];\n        copyGrid.startNode = copyGrid.graph[0][0];\n        copyGrid.endNode = copyGrid.graph[copyGrid.numberOfRows-1][copyGrid.numberOfColumns-1];\n        this.grid.update(copyGrid);\n    }\n\n    changeToDijkstra() {\n        this.setState({\n            algorithm: \"Dijkstra\"\n        }, () => this.reset()\n        );\n    }\n\n    changeToBfs() {\n        this.setState({\n            algorithm: \"BFS\"\n        }, () => this.reset()\n        );\n    }\n\n    changeToDfs() {\n        this.setState({\n            algorithm: \"DFS\",\n        }, () => this.reset()\n        );\n    }\n\n    changeToAstar(){\n        this.setState({\n            algorithm: \"A*\",\n        }, ()=> this.reset()\n        );\n    }\n    \n    search(){\n        if ( this.state.searching ){\n            var newGrid, newStackOfNodes, newVisited, newNodesTouched, continueSearch;\n            if ( this.state.algorithm === 'DFS' ){\n                [newGrid, newStackOfNodes, newVisited, newNodesTouched] = this.searchAlgos.dfsStep(\n                    this.grid.state,\n                    this.state.stackOfNodes,\n                    this.state.visited,\n                    this.state.nodesTouched            \n                );    \n            }\n            if ( this.state.algorithm === 'BFS' ){\n                [newGrid, newStackOfNodes, newVisited, newNodesTouched] = this.searchAlgos.bfsStep(\n                    this.grid.state,\n                    this.state.stackOfNodes,\n                    this.state.visited,\n                    this.state.nodesTouched            \n                );\n            }\n            if ( newGrid.currentNode.x === this.grid.state.endNode.x && newGrid.currentNode.y === this.grid.state.y ){\n                continueSearch = false;\n            } else {\n                continueSearch = true;\n            }\n\n            this.setState({\n                stackOfNodes: newStackOfNodes,\n                visited: newVisited,\n                nodesTouched: newNodesTouched,\n                searching: continueSearch,\n            });\n            this.grid.update(newGrid);\n        }\n    }\n\n    startInterval(){\n        this.intervalID = window.setInterval(this.search, 10);\n    }\n\n    stopInterval(){\n        window.clearInterval(this.intervalID);\n    }\n\n    startSearch() {\n        this.setState({\n            searching: true,\n        }, () => this.startInterval(),\n        );\n    }\n\n    stopSearch() {\n        this.setState({\n            searching: false,\n        }, () => this.stopInterval(),\n        );\n    }\n\n    render(){\n        let stopSearchButton, startSearchButton;\n        if ( this.state.searching ){\n            stopSearchButton = <button onClick={this.stopSearch}>Stop Search</button>\n        } else {\n            stopSearchButton = <button onClick={this.stopSearch} disabled>Stop Search</button>\n        }\n        if ( this.state.searching ){\n            startSearchButton = <button onClick={this.startSearch} disabled>Start Search</button>\n        } else {\n            startSearchButton = <button onClick={this.startSearch}>Start Search</button>\n        }\n        const gridRender = this.grid.state.graph.map(\n            i => i.map(\n            j => <div key={j.x*this.grid.state.numberOfColumns + j.y} style={{backgroundColor: j.color}} className={styles.Node}>        \n                </div>\n            )\n        );\n        return (\n            <div>\n                <p>Current Algorithm = {this.state.algorithm}</p>\n                <button onClick={this.changeToDijkstra}>Dijkstra</button>\n                <button onClick={this.changeToBfs}>BFS</button>\n                <button onClick={this.changeToDfs}>DFS</button>\n                <button onClick={this.changeToAstar}>A*</button>\n                <button onClick={this.reset}>Reset The Board</button>\n                {startSearchButton}\n                {stopSearchButton}\n                <p> Current Node = ({this.grid.state.currentNode.x+1},{this.grid.state.currentNode.y+1}) Destination Node = ({this.grid.state.endNode.x+1},{this.grid.state.endNode.y+1}) </p>\n                <div>\n                    <div className={styles.grid}>{gridRender}</div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default Pathfinder;","import './App.css';\nimport PathFinder from \"./PathFinding/Pathfinder.js\"\n\n\nfunction App() {\n  return (\n    <div>\n      <PathFinder/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"grid\":\"SearchGrid_grid__1Al05\",\"Node\":\"SearchGrid_Node__37977\"};"],"sourceRoot":""}