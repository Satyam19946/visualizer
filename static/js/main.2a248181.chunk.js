(this.webpackJsonpvisualizer=this.webpackJsonpvisualizer||[]).push([[0],{16:function(t,e,r){},17:function(t,e,r){},18:function(t,e,r){"use strict";r.r(e);var s=r(0),a=r(2),i=r.n(a),n=r(10),o=r.n(n),h=(r(16),r(17),r(7)),c=r(3),d=r(4),u=r(1),l=r(6),g=r(5),f=function(t){Object(l.a)(r,t);var e=Object(g.a)(r);function r(){return Object(c.a)(this,r),e.apply(this,arguments)}return Object(d.a)(r,[{key:"changeColorToOrange",value:function(t){t.color="orange"}},{key:"changeColorToBlue",value:function(t){t.color="blue"}},{key:"dfsStep",value:function(t,e,r,s,a){var i=t.endNode,n=t.currentNode;if(r.push(n),n.x===i.x&&n.y===i.y)return t.endNode.color="pink",console.log("Node found"),[t,e,r,s,a+1];var o=[];o.push([n.x+1,n.y]),o.push([n.x-1,n.y]),o.push([n.x,n.y+1]),o.push([n.x,n.y-1]);for(var h=0;h<o.length;h++){var c=o[h];if(c[0]>=0&&c[0]<t.numberOfRows&&c[1]>=0&&c[1]<t.numberOfColumns&&-1===s.indexOf(c[0]*t.numberOfColumns+c[1])&&t.graph[c[0]][c[1]].weight!==1/0){var d=t.graph[c[0]][c[1]];d.parent=n,e.push(d),s.push(c[0]*t.numberOfColumns+c[1])}}return e.forEach(this.changeColorToOrange),r.forEach(this.changeColorToBlue),e.length>=1&&(t.currentNode=e.pop(),t.currentNode.color="green"),[t,e,r,s,a+1]}},{key:"bfsStep",value:function(t,e,r,s,a){var i=t.endNode,n=t.currentNode;if(r.push(n),n.x===i.x&&n.y===i.y)return t.endNode.color="pink",[t,e,r,s,a+1];var o=[];o.push([n.x+1,n.y]),o.push([n.x-1,n.y]),o.push([n.x,n.y+1]),o.push([n.x,n.y-1]);for(var h=0;h<o.length;h++){var c=o[h];if(c[0]>=0&&c[0]<t.numberOfRows&&c[1]>=0&&c[1]<t.numberOfColumns&&-1===s.indexOf(c[0]*t.numberOfColumns+c[1])&&t.graph[c[0]][c[1]].weight!==1/0){var d=t.graph[c[0]][c[1]];d.parent=n,e.push(d),s.push(c[0]*t.numberOfColumns+c[1])}}return e.forEach(this.changeColorToOrange),r.forEach(this.changeColorToBlue),e.length>=1&&(t.currentNode=e.shift(),t.currentNode.color="green"),[t,e,r,s,a+1]}},{key:"aStarStep",value:function(t,e,r,s,a){var i=t.endNode,n=t.currentNode,o=1;if(e.size()&&(o=e.peek()[1]),r.push(n),n.x===i.x&&n.y===i.y)return t.endNode.color="pink",[t,e,r,s,a+1];var h=[];h.push([n.x+1,n.y]),h.push([n.x-1,n.y]),h.push([n.x,n.y+1]),h.push([n.x,n.y-1]);for(var c=0;c<h.length;c++){var d=h[c];if(d[0]>=0&&d[0]<t.numberOfRows&&d[1]>=0&&d[1]<t.numberOfColumns&&-1===s.indexOf(d[0]*t.numberOfColumns+d[1])&&t.graph[d[0]][d[1]].weight!==1/0){var u=t.graph[d[0]][d[1]];u.parent=n;var l=Math.abs(u.x-i.x)+Math.abs(u.y-i.y);e.push([u,o+u.weight+l]),s.push(d[0]*t.numberOfColumns+d[1])}}return e.forEachNode(this.changeColorToOrange),r.forEach(this.changeColorToBlue),e.size()&&(t.currentNode=e.pop()[0],t.currentNode.color="green"),[t,e,r,s,a+1]}},{key:"dijkstraStep",value:function(t,e,r,s,a){var i=t.endNode,n=t.currentNode,o=1;if(e.size()&&(o=e.peek()[1]),r.push(n),n.x===i.x&&n.y===i.y)return t.endNode.color="pink",[t,e,r,s,a+1];var h=[];h.push([n.x+1,n.y]),h.push([n.x-1,n.y]),h.push([n.x,n.y+1]),h.push([n.x,n.y-1]);for(var c=0;c<h.length;c++){var d=h[c];if(d[0]>=0&&d[0]<t.numberOfRows&&d[1]>=0&&d[1]<t.numberOfColumns&&-1===s.indexOf(d[0]*t.numberOfColumns+d[1])&&t.graph[d[0]][d[1]].weight!==1/0){var u=t.graph[d[0]][d[1]];u.parent=n,e.push([u,o+u.weight]),s.push(d[0]*t.numberOfColumns+d[1])}}return e.forEachNode(this.changeColorToOrange),r.forEach(this.changeColorToBlue),e.size()&&(t.currentNode=e.pop()[0],t.currentNode.color="green"),[t,e,r,s,a+1]}}]),r}(a.Component),p=function(){function t(e,r){var s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"white";Object(c.a)(this,t),this.x=e,this.y=r,this.color=s,this.parent=null,this.weight=1}return Object(d.a)(t,[{key:"getX",value:function(){return this.x}},{key:"getY",value:function(){return this.y}},{key:"getColor",value:function(){return this.color}},{key:"getParent",value:function(){return this.parent}},{key:"setColor",value:function(t){this.color=t}},{key:"setParent",value:function(t){this.parent=t}}]),t}(),b=function(t){Object(l.a)(r,t);var e=Object(g.a)(r);function r(t){var s;Object(c.a)(this,r),(s=e.call(this,t)).state={numberOfRows:20,numberOfColumns:45,graph:[[]],startNode:new p(0,0,"yellow"),currentNode:new p(0,0,"green"),endNode:new p(0,0,"red")};for(var a=[],i=0;i<s.state.numberOfRows;i++){for(var n=[],o=0;o<s.state.numberOfColumns;o++){var h=new p(i,o);n.push(h)}a.push(n)}return a[0][0].color="yellow",a[s.state.numberOfRows-1][s.state.numberOfColumns-1].color="red",s.state.graph=a,s.state.startNode=a[0][0],s.state.endNode=a[s.state.numberOfRows-1][s.state.numberOfColumns-1],s.update=s.update.bind(Object(u.a)(s)),s}return Object(d.a)(r,[{key:"update",value:function(t){console.log("UPDATING THE GRID"),this.setState(t)}}]),r}(a.Component),m=r(8),v=r.n(m),O=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(t,e){return t>e};Object(c.a)(this,t),this._heap=[],this._comparator=e}return Object(d.a)(t,[{key:"heap",value:function(){return this._heap}},{key:"size",value:function(){return this._heap.length}},{key:"isEmpty",value:function(){return 0===this._heap.length}},{key:"peek",value:function(){return this._heap.length>=1?this._heap[0]:void 0}},{key:"push",value:function(t){for(var e=!1,r=0;r<this._heap.length&&!e;r++)this._heap[r][1]>t[1]&&(this._heap.splice(r,0,t),e=!0);e||this._heap.splice(this._heap.length,0,t)}},{key:"pop",value:function(){return this._heap.length>0?this._heap.shift():void 0}},{key:"empty",value:function(){this._heap=[]}},{key:"forEachNode",value:function(t){for(var e=0;e<this.size();e++)t(this._heap[e][0])}}]),t}(),j=function(t){return"DFS"===t?"Depth-First Search or DFS is a classic Path-finding Algorithm. It does not guarantee a shortest path but it guarantees that if there exists a path from the starting node to the destination, it will find it. It uses a stack in its implementation and is very useful for tree-traversals (pre/in/post) where we need to go down one entire branch before switching to the different branch. The last node that is added, is explored first in this algorithm. Both BFS and DFS do not work for weighted graphs, so we assume that every node has the same weight and that is 1.":"Dijkstra"===t?"Dijkstra is a guaranteed path finder and it finds the path with the lowest cost. A major difference between BFS/DFS and Dijkstra is that Dijkstra works for weighted paths where the cost of all nodes is not the same. Dijkstra's algorithm is named after Edsger W. Dijkstra. Using a Priority Queue in its implementation, we can find the lowest cost path from one node to all the other nodes, as a priority queue would search the nodes with the smallest cost first. In my implementation, I use min-heap to implement the priority queue.":"BFS"===t?"Breadth-First Search or BFS is a guaranteed shortest path-finder in a graph where all nodes cost the same to visit. It uses a queue in its implementation. We first visit and explore all the nodes at one level and then go upto the upper level. Since all nodes have the same cost, it can be proved using induction that all the nodes at each level have the same cost. This algorithm is used in Tree-traversals when we want to search an entire level of tree before going down to the second level. This traversal is known as level-order traversal.":'A* works like Dijkstra but uses the concept of a heuristics. A heuristics is a well-defined function which gives us an estimate of how bad/good visiting the current path might be. In this case, we use the "Manhattan Distance" between the current node and the destination to get an estimate of how good we are doing. The heuristics should be consistent for all the nodes and should not result in a decreased cost. (Manhattan distance fulfills both the conditions and is an extremely popular heuristics.'},y="gray",w="lightgray",k="black",S="white",x=function(t){Object(l.a)(r,t);var e=Object(g.a)(r);function r(t){var s;return Object(c.a)(this,r),(s=e.call(this,t)).state={algorithm:"Dijkstra",searching:!1,arrayOfNodes:[],visited:[],nodesTouched:[],pqOfNodes:new O,numberOfIterations:0},s.grid=new b,s.intervalID=void 0,s.searchAlgos=new f,s.description=j(s.state.algorithm),s.changeToDijkstra=s.changeToDijkstra.bind(Object(u.a)(s)),s.changeToBfs=s.changeToBfs.bind(Object(u.a)(s)),s.changeToDfs=s.changeToDfs.bind(Object(u.a)(s)),s.changeToAstar=s.changeToAstar.bind(Object(u.a)(s)),s.startSearch=s.startSearch.bind(Object(u.a)(s)),s.stopSearch=s.stopSearch.bind(Object(u.a)(s)),s.search=s.search.bind(Object(u.a)(s)),s.startInterval=s.startInterval.bind(Object(u.a)(s)),s.stopInterval=s.stopInterval.bind(Object(u.a)(s)),s.reset=s.reset.bind(Object(u.a)(s)),s.changeDescription=s.changeDescription.bind(Object(u.a)(s)),s.randomizeMaze=s.randomizeMaze.bind(Object(u.a)(s)),s.randomizeMaze(),s}return Object(d.a)(r,[{key:"reset",value:function(){this.setState({searching:!1,arrayOfNodes:[],visited:[],nodesTouched:[],pqOfNodes:new O,numberOfIterations:0});for(var t=0;t<this.grid.state.numberOfRows;t++)for(var e=0;e<this.grid.state.numberOfColumns;e++)1===this.grid.state.graph[t][e].weight?this.grid.state.graph[t][e].color=S:70===this.grid.state.graph[t][e].weight?(this.grid.state.graph[t][e].color=y,"BFS"!==this.state.algorithm&&"DFS"!==this.state.algorithm||(this.grid.state.graph[t][e].color=S)):30===this.grid.state.graph[t][e].weight?(this.grid.state.graph[t][e].color=w,"BFS"!==this.state.algorithm&&"DFS"!==this.state.algorithm||(this.grid.state.graph[t][e].color=S)):this.grid.state.graph[t][e].weight===1/0&&(this.grid.state.graph[t][e].color="black");this.grid.state.graph[0][0].color="yellow",this.grid.state.graph[this.grid.state.numberOfRows-1][this.grid.state.numberOfColumns-1].color="red",this.grid.state.currentNode=this.grid.state.graph[0][0],this.grid.state.startNode=this.grid.state.graph[0][0],this.grid.state.endNode=this.grid.state.graph[this.grid.state.numberOfRows-1][this.grid.state.numberOfColumns-1],this.grid.update(this.grid.state),this.changeDescription()}},{key:"randomizeMaze",value:function(){for(var t=0;t<this.grid.state.numberOfRows;t++)for(var e=0;e<this.grid.state.numberOfColumns;e++)if("Dijkstra"===this.state.algorithm||"A*"===this.state.algorithm){var r=Math.random();r>.9?(this.grid.state.graph[t][e].weight=1/0,this.grid.state.graph[t][e].color=k):r>.6?(this.grid.state.graph[t][e].weight=70,this.grid.state.graph[t][e].color=y):r>.3?(this.grid.state.graph[t][e].weight=30,this.grid.state.graph[t][e].color=w):this.grid.state.graph[t][e].weight=1}else{Math.random()>.8?(this.grid.state.graph[t][e].weight=1/0,this.grid.state.graph[t][e].color=k):this.grid.state.graph[t][e].weight=1}this.reset()}},{key:"changeDescription",value:function(){this.description=j(this.state.algorithm)}},{key:"changeToDijkstra",value:function(){var t=this;this.setState({algorithm:"Dijkstra"},(function(){return t.reset()}))}},{key:"changeToBfs",value:function(){var t=this;this.setState({algorithm:"BFS"},(function(){return t.reset()}))}},{key:"changeToDfs",value:function(){var t=this;this.setState({algorithm:"DFS"},(function(){return t.reset()}))}},{key:"changeToAstar",value:function(){var t=this;this.setState({algorithm:"A*"},(function(){return t.reset()}))}},{key:"tracePathFromStartToEnd",value:function(t){for(var e=t.endNode;e.x!==t.startNode.x||e.y!==t.startNode.y;)e.color="yellow",e=e.parent;return e.color="yellow",t}},{key:"search",value:function(){if(this.state.searching){var t,e,r,s,a,i,n;if("DFS"===this.state.algorithm){var o=this.searchAlgos.dfsStep(this.grid.state,this.state.arrayOfNodes,this.state.visited,this.state.nodesTouched,this.state.numberOfIterations),c=Object(h.a)(o,5);t=c[0],e=c[1],r=c[2],s=c[3],n=c[4],this.setState({arrayOfNodes:e,visited:r,nodesTouched:s,numberOfIterations:n})}else if("BFS"===this.state.algorithm){var d=this.searchAlgos.bfsStep(this.grid.state,this.state.arrayOfNodes,this.state.visited,this.state.nodesTouched,this.state.numberOfIterations),u=Object(h.a)(d,5);t=u[0],e=u[1],r=u[2],s=u[3],n=u[4],this.setState({arrayOfNodes:e,visited:r,nodesTouched:s,numberOfIterations:n})}else if("A*"===this.state.algorithm){var l=this.searchAlgos.aStarStep(this.grid.state,this.state.pqOfNodes,this.state.visited,this.state.nodesTouched,this.state.numberOfIterations),g=Object(h.a)(l,5);t=g[0],i=g[1],r=g[2],s=g[3],n=g[4],this.setState({pqOfNodes:i,visited:r,nodesTouched:s,numberOfIterations:n})}else if("Dijkstra"===this.state.algorithm){var f=this.searchAlgos.dijkstraStep(this.grid.state,this.state.pqOfNodes,this.state.visited,this.state.nodesTouched,this.state.numberOfIterations),p=Object(h.a)(f,5);t=p[0],i=p[1],r=p[2],s=p[3],n=p[4],this.setState({pqOfNodes:i,visited:r,nodesTouched:s,numberOfIterations:n})}t.currentNode.x===this.grid.state.endNode.x&&t.currentNode.y===this.grid.state.endNode.y?(a=!1,t=this.tracePathFromStartToEnd(t)):a=!0,this.setState({searching:a}),this.grid.update(t)}}},{key:"startInterval",value:function(){this.intervalID=window.setInterval(this.search,10)}},{key:"stopInterval",value:function(){window.clearInterval(this.intervalID)}},{key:"startSearch",value:function(){var t=this;this.setState({searching:!0},(function(){return t.startInterval()}))}},{key:"stopSearch",value:function(){var t=this;this.setState({searching:!1},(function(){return t.stopInterval()}))}},{key:"render",value:function(){var t,e,r=this;t=this.state.searching?Object(s.jsx)("button",{onClick:this.stopSearch,children:"Stop Search"}):Object(s.jsx)("button",{onClick:this.stopSearch,disabled:!0,children:"Stop Search"}),e=this.state.searching?Object(s.jsx)("button",{onClick:this.startSearch,disabled:!0,children:"Start Search"}):Object(s.jsx)("button",{onClick:this.startSearch,children:"Start Search"});var a=this.grid.state.graph.map((function(t){return t.map((function(t){return Object(s.jsx)("div",{style:{backgroundColor:t.color},className:v.a.Node},t.x*r.grid.state.numberOfColumns+t.y)}))}));return Object(s.jsxs)("div",{children:[Object(s.jsx)("button",{onClick:this.changeToDijkstra,disabled:"Dijkstra"===this.state.algorithm,children:"Dijkstra"}),Object(s.jsx)("button",{onClick:this.changeToBfs,disabled:"BFS"===this.state.algorithm,children:"BFS"}),Object(s.jsx)("button",{onClick:this.changeToDfs,disabled:"DFS"===this.state.algorithm,children:"DFS"}),Object(s.jsx)("button",{onClick:this.changeToAstar,disabled:"A*"===this.state.algorithm,children:"A*"}),Object(s.jsx)("button",{onClick:this.reset,children:"Reset The Board"}),Object(s.jsx)("button",{onClick:this.randomizeMaze,children:"Randomize The Maze"}),e,t,Object(s.jsx)("button",{children:Object(s.jsx)("a",{href:"https://github.com/satyam19946/visualizer",children:"Github link"})}),Object(s.jsx)("div",{className:v.a.Description,children:this.description}),Object(s.jsx)("br",{}),"Black Nodes cannot be passed and act as blockers. Darker nodes are high weighted while lighter are low weighted. 'Randomize The Maze' randomly assigns each the weight to each node in the grid.",Object(s.jsx)("br",{}),"Current Node = (",this.grid.state.currentNode.x+1,",",this.grid.state.currentNode.y+1,") Destination Node = (",this.grid.state.endNode.x+1,",",this.grid.state.endNode.y+1,") Number of Iterations = ",this.state.numberOfIterations,Object(s.jsx)("div",{children:Object(s.jsx)("div",{className:v.a.grid,children:a})})]})}}]),r}(a.Component);var N=function(){return Object(s.jsx)("div",{children:Object(s.jsx)(x,{})})};o.a.render(Object(s.jsx)(i.a.StrictMode,{children:Object(s.jsx)(N,{})}),document.getElementById("root"))},8:function(t,e,r){t.exports={grid:"SearchGrid_grid__3LqTd",Node:"SearchGrid_Node__2S4hf",Description:"SearchGrid_Description__6iyT7"}}},[[18,1,2]]]);
//# sourceMappingURL=main.2a248181.chunk.js.map